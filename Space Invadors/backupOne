Version 1:
   
   import java.awt.event.ActionEvent;
   import java.awt.event.ActionListener;
   import java.awt.Graphics;
   import java.awt.Image;
   import java.awt.event.KeyEvent;
   import java.awt.event.KeyListener;
   import java.awt.Dimension;
   import java.awt.Toolkit;
   import java.awt.*;
   
   import java.util.Iterator;
   import javax.swing.ImageIcon;
   import javax.swing.JFrame;
   import javax.swing.JOptionPane;
   import javax.swing.JPanel;
   import javax.swing.JButton;
   import javax.swing.*;
   
   import java.applet.Applet;
   import java.applet.AudioClip;
   import java.net.URL;
   
   public class Space_invadors extends JFrame{
   
   	// The background sound for the game:
      private static URL mainURL = Space_invadors.class.getResource("backSound.wav");
      private static AudioClip mainClip = Applet.newAudioClip(mainURL);
   
      private Game gameObj = new Game(null, null, null); 
      
      private JPanel menuePanel; 
      
      private final static Dimension auotDim = Toolkit.getDefaultToolkit().getScreenSize();
      
      public Space_invadors(){
      
         System.out.println(javax.swing.SwingUtilities.isEventDispatchThread());
         frameCreate();
         new StartMenus();
         
         //Game t = new Game(null,null,null);
         //t.gameRun(null,null,null);
         
         //gameObj.gameRun(null,null,null);
      }
      
      private void frameCreate(){
      
         setTitle("Space Invaders");
         setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
         setSize(800, 800);
         setResizable(false);
         setLocation(auotDim.width / 2 - getSize().width / 2, auotDim.height / 2 - getSize().height / 2);
         setLayout(new GridLayout(0, 1));
         setVisible(false);
      }
   
      //private class StartMenus extends JFrame implements ActionListener{
      private class StartMenus implements ActionListener{
      
         //Dimension auotDim = Toolkit.getDefaultToolkit().getScreenSize();
         
         //Game newGame = new Game(null, null, null);
      
         URL[] players = { Space_invadors.class.getResource("menuePlayer1.png"),
                     		Space_invadors.class.getResource("menuePlayer2.png"),
                     		Space_invadors.class.getResource("menuePlayer3.png"),
                     		Space_invadors.class.getResource("menuePlayer4.png") };
                           
         JButton[] playerButtons = {new JButton("The Blue Knight", new ImageIcon(players[0])),
                              		new JButton("Terminator",      new ImageIcon(players[1])),
                              		new JButton("The Red Eagle",   new ImageIcon(players[2])),
                              		new JButton("The Phantom",     new ImageIcon(players[3])), 
                                    new JButton("DEFAULT")};
      
         public StartMenus() {
         
         	// Menu one - Introduction:
            JLabel welcome = new JLabel("Hello player and wellcome! \n" + 
                                        "Please choose your desired spaceship from the following menue!");
            welcome.setFont(new Font("Arial", Font.BOLD, 18));
            JOptionPane.showMessageDialog(null, welcome, "WELCOME", JOptionPane.WARNING_MESSAGE);
         /*
         	// Menu two - player, enemy and background:
            setTitle("Space Invaders");
            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            setSize(800, 800);
            setResizable(false);
            setLocation(auotDim.width / 2 - getSize().width / 2, auotDim.height / 2 - getSize().height / 2);
            setLayout(new GridLayout(0, 1));
            setVisible(true);
            */
            menuePanel = new JPanel(new GridLayout(0, 1)); 
            //menuePanel.
         
         	// Setting the color of each button:
            for (JButton x : playerButtons) {
            
               x.setFont(new Font(Font.SANS_SERIF, Font.BOLD, 50));
            
               if (x == playerButtons[0])
                  playerButtons[0].setForeground(Color.BLUE);
               else if (x == playerButtons[1])
                  playerButtons[1].setForeground(Color.YELLOW);
               else if (x == playerButtons[2])
                  playerButtons[2].setForeground(Color.RED);
               else if (x == playerButtons[3])
                  playerButtons[3].setForeground(Color.GRAY);
               else
                  playerButtons[4].setForeground(Color.BLACK);
            
               menuePanel.add(x);
            }
         
            
            
         	// Assigning actionListener to each buttom
            for(int i = 0; i < 5; i++){
               playerButtons[i].addActionListener(this);
            }
            /*for (JButton x : playerButtons)
            
               x.addActionListener(
                  new ActionListener() {
                     public void actionPerformed(ActionEvent e) {
                     
                        dispose();
                     
                        if (e.getActionCommand() == "The Blue Knight")
                           newGame.gameRun(new ImageIcon(players[0]), null, null);
                        else if (e.getActionCommand() == "Terminator")
                           newGame.gameRun(new ImageIcon(players[1]), null, null);
                        else if (e.getActionCommand() == "The Red Eagle")
                           newGame.gameRun(new ImageIcon(players[2]), null, null);
                        else if (e.getActionCommand() == "The Phantom")
                           newGame.gameRun(new ImageIcon(players[3]), null, null);
                        else
                           newGame.gameRun(null, null, null);
                     }
                  });*/
                  
            add(menuePanel);
            setVisible(true);
         }
         
         public void actionPerformed(ActionEvent e){
         
            dispose();
                     
            if (e.getActionCommand() == "The Blue Knight")
               //newGame.gameRun(new ImageIcon(players[0]), null, null);
               gameObj.gameRun(new ImageIcon(players[0]), null, null);
            else if (e.getActionCommand() == "Terminator")
               //newGame.gameRun(new ImageIcon(players[1]), null, null);
               gameObj.gameRun(new ImageIcon(players[1]), null, null);
            else if (e.getActionCommand() == "The Red Eagle")
               //newGame.gameRun(new ImageIcon(players[2]), null, null);
               gameObj.gameRun(new ImageIcon(players[2]), null, null);
            else if (e.getActionCommand() == "The Phantom")
               //newGame.gameRun(new ImageIcon(players[3]), null, null);
               gameObj.gameRun(new ImageIcon(players[3]), null, null);
            else
               //newGame.gameRun(null, null, null);
               gameObj.gameRun(null, null, null);
         }
      }
   
      private class Game extends JPanel implements KeyListener {
      
      	// JProgressBar prg; 
         
         private static final int NUM_OF_TARGETS_COL = 10;// Can't be less than 10
         private static final int NUM_OF_TARGETS_ROW = 3;
         private static final int NUM_OF_OBSTACLES = 7;
      
         //private JFrame frame;// = new JFrame();
      
         private Image background;
      	// private ImageIcon deadMeat = new ImageIcon(this.getClass().getResource("Explosion.png")); // Add the explosion!!!!
      
         private int targetsVelocity = 0; // initial velocity of targets
         private int TARGET_LIVES = 1; // minimum life for the target
         private int TARGET_SPEED = 1; // minimum speed for the target
         private Target[][] targets = new Target[NUM_OF_TARGETS_ROW][NUM_OF_TARGETS_COL]; // 2D array to hold more than 1 row of enemy
      
         private Player player;
         private int PLAYER_LIVES = 3; // minimum life for the player
      
         private Obstacle[] obstacles = new Obstacle[NUM_OF_OBSTACLES];
      
         private boolean isAnyAlive = false; // Used with the player's bullets to determine if they are excited on the screen
         private boolean isAnyAliveEnemyBullets = false; // Used for the enemy's bullets
         private boolean enemyAlive = false; // If the player didn't kill all the targets then a different menue will be shown
      
         private URL enemyDie = Space_invadors.class.getResource("enemyDying.wav");
         private URL playerDie = Space_invadors.class.getResource("playerDying.wav");
         private URL enemyS = Space_invadors.class.getResource("enemyShoot.wav");
         private URL playerS = Space_invadors.class.getResource("playerShoot.wav");
         private AudioClip enemyClip = Applet.newAudioClip(enemyDie);
         private AudioClip playerClip = Applet.newAudioClip(playerDie);
         private AudioClip enemyShoot = Applet.newAudioClip(enemyS);
         private AudioClip playerShoot = Applet.newAudioClip(playerS);
      
         private JComboBox optionsMenue;
         private URL mainURL = Space_invadors.class.getResource("backSound.wav");
         private AudioClip mainClip = Applet.newAudioClip(mainURL);
      
         private final Dimension autoDim = Toolkit.getDefaultToolkit().getScreenSize();
      
         public int change = 0;
      
      	/**
      	 * The constractor of the class will instantiate the obstacle, target,
      	 * Bullet and the player classes in order to create full functioning
      	 * game. Also, will create a new object for the background image.
      	 * 
      	 * @param obstaclesIcon
      	 *            - Passing an image parameter to replace the default one
      	 *            for the obstacle view.
      	 * @param enemyIcon
      	 *            - Passing an image parameter to replace the default one
      	 *            for the enemy view.
      	 * @param playerIcon
      	 *            - Passing an image parameter to replace the default one
      	 *            for the player view.
      	 */
         public Game(ImageIcon playerIcon, ImageIcon enemyIcon, ImageIcon obstaclesIcon) {
            
         	// enemyDie = Space_invadors.class.getResource("Dying1.wav");
         	// enemyClip = Applet.newAudioClip(enemyDie);
         	/*
         	 * prg = new JProgressBar(0,100); prg.setValue(100);
         	 * prg.setStringPainted(true); prg.setEnabled(true); add(prg);
         	 * //prg.setString("100");
         	 */
         
         	// Add the background:
            background = new ImageIcon(getClass().getResource("BackGray.jpg")).getImage();
            
         	// Creates obstacles
            int obstacleX = 25, lives = 5; // each brick has 5 lives
            for (int i = 0; i < obstacles.length; i++, obstacleX += 100) {
            
               if (obstaclesIcon == null)
                  obstacles[i] = new Obstacle(null, obstacleX + 50, 500, lives);
               else
                  obstacles[i] = new Obstacle(obstaclesIcon.getImage(), obstacleX + 50, 500, lives);
            
               add(obstacles[i]);
            }
         
         	// Create targets
            int targetX = 0, targetY = 50;
         
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++, targetX += 50) {
               
                  if (enemyIcon == null)
                     targets[a][i] = new Target(null, targetX, targetY, TARGET_LIVES);
                  else
                     targets[a][i] = new Target(enemyIcon.getImage(), targetX, targetY, TARGET_LIVES);
               
                  add(targets[a][i]);
               }
            
               targetY += 50;
               targetX = 0;
            }
         
         	// Create the player:
            if (playerIcon == null)
               player = new Player(null, 350, 650, PLAYER_LIVES, 0);
            else
               player = new Player(playerIcon.getImage(), 350, 650, PLAYER_LIVES, 0);
         
            add(player); // Adds player to the panel
            
            //this.addKeyListener(this); // Adds keyListener to the panel <====================
            addKeyListener(this); // Adds keyListener to the panel
         }
      
      	/**
      	 * The paint method is used to paint an object as a graphical user
      	 * interface. The paintComponent method will be called from the repaint
      	 * method.
      	 * 
      	 * @param g
      	 *            - The specified graphic object to paint in the window
      	 *            (self-customize one)
      	 */
         @Override
         protected synchronized void paintComponent(Graphics g) {
         
         	// The background of the window will be drawn manually, therefore no
         	// need for:
         	// super.paintComponent(g); //Passes the graphics context off to the
         	// component's UI delegate, which paints the panel's background
         
            g.drawImage(background, 0, 0, getWidth(), getHeight(), null);
         
            player.drawPlayer(g); // draws player on the screen
         
            for (int i = 0; i < obstacles.length; i++)
               obstacles[i].drawObstacles(g); // draws obstacles on the screen
         
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) { // draws targets on
            												// the screen
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
               
                  targets[a][i].drawTarget(g);
               
               	// Drawing the bullets for the enemy:
                  for (Iterator<Bullet> it = targets[a][i].bulletsE.iterator(); it
                  		.hasNext();/* NO arg */) {
                  
                     Bullet temp = it.next();
                     temp.drawBullet(g);
                  }
               }
            }
         
         	// Drawing the bullets for the player:
            for (Iterator<Bullet> it = player.bulletsP.iterator(); it.hasNext();) {// bullets.iterator()
               Bullet b = it.next();
               b.drawBullet(g); // draws player bullets on the screen from the
            						// Player class
            }
         
            g.dispose();// if i cancel that line there are gray squers on top
         				// for some reason
         }
      
      	/**
      	 * moveObjects method is used to move the objects on the screen, in this
      	 * case the objects are the bullets/targets. The method will not paint
      	 * the objects, it will only move them to a different location on the
      	 * panel.
      	 */
         public void moveObjects() {
         
         /*Creating a local variable to direct the enemy on the y-value, 
           after the enemy reached every edge, it will go down ten levels:*/
            int moveY = 0;
         
         	/*
         	 * The interface Iterator<E> is a linked list that takes a type
         	 * Bullet (from the Bullet class) and iterate among the elements
         	 * inside the linked list that the Bullet class has. E - The type of
         	 * elements returned by this iterator (Bullet object)
         	 * 
         	 * The "it" is a pointer pointing to the head of the list and as
         	 * long that .iterator returns another element the for loop will
         	 * continue
         	 */
         	// Moving the player bullets:
            for (Iterator<Bullet> it = player.bulletsP.iterator(); it.hasNext();/* NO arg */) {
            
               Bullet tempBullet = it.next(); // pull out a Bullet objects from the list; 1 each time
               isAnyAlive = tempBullet.isAlive ? true : false;
               tempBullet.y = tempBullet.y - 13; // move the bullet 13 pixels up each repaint()
            }
         
         	// ----------------------------------------------------------------------------------------------------------------------------------
         	// Check if the targets got to either one of the sides:
            if (targets[0][NUM_OF_TARGETS_COL - 1].x == 750) { // targets move
            													// in relation
            													// to the far
            													// right target
               targetsVelocity = -1 * TARGET_SPEED; // targets move left
               moveY = 10; // targets go down one row
            } 
            else if (targets[0][NUM_OF_TARGETS_COL - 1].x == 450) { // targets
            															// move
            															// in
            															// relation
            															// to
            															// the
            															// far
            															// left
            															// target
               targetsVelocity = TARGET_SPEED; // targets move right
               moveY = 10; // targets go down one row
            }
         	// ----------------------------------------------------------------------------------------------------------------------------------
         
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
               
               	// ---------------------------------------------------------------------------------------
                  for (Iterator<Bullet> it = targets[a][i].bulletsE.iterator(); it
                  		.hasNext();/* NO arg */) {
                  
                     Bullet temp = it.next();
                     isAnyAliveEnemyBullets = temp.isAlive ? true : false;
                     temp.y += 6;
                  }
               	// ---------------------------------------------------------------------------------------
               
                  targets[a][i].x = targets[a][i].x + targetsVelocity; // move
               															// the
               															// targets
               															// to
               															// either
               															// left
               															// or
               															// right
                  targets[a][i].y = targets[a][i].y + moveY; // move the
               												// targets down
               }
            }
         }
      
      	/**
      	 * The anyHit method measuring the bullet and the target x and y axis to
      	 * report if ther's a hit or not.
      	 */
         public synchronized void anyHit() { // compares each bullet x,y to each target x,y
         
         	// -----------------------------THE PLAYER BULLET-------------------------------------------
            for (Iterator<Bullet> it = player.bulletsP.iterator(); it.hasNext(); /* NO args */) {
            
               Bullet tempBullet = it.next(); // pulling out 1 bullet object
            									// from the list at a time
            
               if (tempBullet.isAlive) { // if bullet is still on the screen
               	// Check the position of the bullet corresponding to the
               	// target:
                  for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
                  
                     for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
                     
                        if (targets[a][i].isAlive) { // If the enemy is
                        								// still in the game
                        
                           boolean hit = false;
                        
                        	// Checking for matching locations:
                           if (tempBullet.x >= targets[a][i].x && tempBullet.x <= targets[a][i].x + 50
                           		&& tempBullet.y >= targets[a][i].y && tempBullet.y <= targets[a][i].y + 50)
                              hit = true; // If there is a hit then the
                        					// variable will be change to
                        					// true
                        
                           if (hit) {// If the bullet hit the target:
                              tempBullet.isAlive = false;// The bullet is
                           								// deleted from
                           								// the screen
                           
                              if (targets[a][i].lives > 0) {// If the
                              								// target
                              								// had more
                              								// than 0,
                              								// subtract
                              								// 1
                                 targets[a][i].lives -= 1;
                              }
                              if (targets[a][i].lives == 0) {// if target
                              								// has 0
                              								// lives,
                              								// delete
                              								// the icon
                              								// from the
                              								// screen
                                 targets[a][i].isAlive = false;
                                 enemyClip.play();
                              }
                           }
                        }
                     
                        if (tempBullet.isAlive && tempBullet.y <= 0) // if
                        												// bullet
                        												// flew
                        												// off
                        												// the
                        												// screen
                        												// without
                        												// hitting
                        												// any
                        												// targets
                           tempBullet.isAlive = false;
                     }
                  }
               
               	// Check the position of the bullet corresponding to the
               	// obstacle:
                  for (int i = 0; i < obstacles.length; i++) {
                  
                     boolean hit = false;
                  
                     if (obstacles[i].isAlive) {
                     
                        if (tempBullet.x >= obstacles[i].x && tempBullet.x <= obstacles[i].x + 55
                        		&& tempBullet.y >= obstacles[i].y && tempBullet.y <= obstacles[i].y + 30)
                        
                           hit = true;
                     
                        if (hit) {
                           tempBullet.isAlive = false;
                           obstacles[i].lives -= 1; // reduces the brick
                        								// life by 1;
                        }
                        if (obstacles[i].lives == 0) {
                           obstacles[i].isAlive = false; // brick dies
                        									// after 5 hits
                        }
                     }
                  }
               }
            }
         
         	// -----------------------------THE ENEMY BULLET-------------------------------------------
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
               
                  for (Iterator<Bullet> it = targets[a][i].bulletsE.iterator(); it.hasNext();/* NO arg */) {
                  
                  	// Checking the position of the BULLET of EACH ENEMY:
                  
                     Bullet temp = it.next();
                  
                     if (temp.isAlive) {
                     
                        boolean hit = false;
                     
                     	// Check if one of the bullets of the enemy match
                     	// the location of the player:
                        if (temp.x >= player.x && temp.x <= player.x + 50 && temp.y >= player.y
                        		&& temp.y <= player.y + 50) {
                           hit = true;
                        }
                        if (hit) {// If the bullet hit the Player:
                           temp.isAlive = false;// The enemy's bullet is deleted from the screen
                        
                           if (player.lives > 0) {// If the Player had more than 0, subtract 1
                              player.lives -= 1;
                           }
                        }
                     }
                  
                  	// If there was no hit:
                     if (temp.isAlive && temp.y >= 800){ //if bullet flew off the screen without hitting any targets
                        isAnyAliveEnemyBullets = false;// ?????????????????????? NOT SURE!!!!!!!!!!!!!!!!
                        temp.isAlive = false;
                     }
                  }
               }
            }
         }
      
         boolean isGameOver() { // Checks if alive targets are left
         
            boolean gameOver = true;
         
            Dead: for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
               
                  if (targets[a][i].isAlive) {
                     gameOver = false;
                  
                  	// If the player didn't kill all the targets he/she
                  	// automatically lose
                     if (targets[a][i].y == 500) {
                     
                        gameOver = true;
                        enemyAlive = true;
                     
                        playerClip.play();
                     
                        break Dead;
                     }
                  }
               }
            }
         
         	// ADD HERE THE CASE WHEN THE USER GOT KILLED BY THE ENEMY
            if (player.lives == 0) {
               playerClip.play();
               JOptionPane.showMessageDialog(null, "YOU'RE A DEAD MEAT!!!");
            
               gameOver = true;
            }
         
            return gameOver;
         }
      
         public void enemyShoot() {
         
            //synchronized(this){
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
               
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
                  
                  // if there is an enemy at the corrent location AND there
                  // is no bullets on the screen from the enemy then:
                  if (targets[a][i].isAlive && !isAnyAliveEnemyBullets) {
                     enemyShoot.play();
                     // Releases a bullet from where the player currently is:
                     Bullet enemyBullet = new Bullet(targets[a][i].x + 10, targets[a][i].y + 35, 1);
                      // Add the bullet to the list of Bullets:
                     targets[a][i].bulletsE.add(enemyBullet); 
                     // Add the bullet to the screen:
                     add(enemyBullet); 
                  }
               }
            }
            //}
         }
      
         public void startMenue() {
         
         	// JOptionPane to inform about selcting the level"
            JLabel difficulty = new JLabel("Please choose a level of dificulty from the menue");
            difficulty.setFont(new Font("Arial", Font.BOLD, 18));
            JOptionPane.showMessageDialog(null, difficulty, "DIFFICULTY", JOptionPane.WARNING_MESSAGE);
         
         	// Create the options for the player:
            String[] options = { "Grandma (Easy)", "Player (Mid)", "KILL ZONE (Hard)" };
            JComboBox optionsMenue = new JComboBox(options);
            optionsMenue.setEditable(false);
            JOptionPane.showMessageDialog(null, optionsMenue, "SELECT YOUR LEVEL!", JOptionPane.QUESTION_MESSAGE);
         
         	// Adjust the difficulty accordingly:
            switch (optionsMenue.getSelectedIndex()) {
            
               case 0:// Easy
                  {
                     TARGET_LIVES = 1;
                     TARGET_SPEED = 1;
                     break;
                  }
               case 1:// Mid
                  {
                     TARGET_LIVES = 2;
                     TARGET_SPEED = 2;
                     break;
                  }
               case 2:// Hard
                  {
                     TARGET_LIVES = 3;
                     TARGET_SPEED = 3;
                     break;
                  }
            }
         	// return optionsMenue;
         }
      
         @Override public void keyTyped(KeyEvent e) {/* not in use */}
         @Override public void keyReleased(KeyEvent e) {/* not in use */}
         @Override public void keyPressed(KeyEvent e) {
         
            int code = e.getKeyCode();
         
            if (code == KeyEvent.VK_RIGHT) {
            
               if (!(player.x >= 700)) {
                  player.x = player.x + 10;
               }
            }
            
            else if (code == KeyEvent.VK_LEFT) {
            
               if (!(player.x <= 0)) {
                  player.x = player.x - 10;
               }
            }
            
            else if (code == KeyEvent.VK_SPACE) { // releases a bullet each time
            										// SPACE pressed
            
               if (!isAnyAlive) { // Checks that there is no bullets in the
               					// screen before shooting new one
                  playerShoot.play();
                  Bullet bullet = new Bullet(player.x + 29, player.y + 0, 0); // Releases
               																// a
               																// bullet
               																// from
               																// where
               																// the
               																// player
               																// currently
               																// is
                  player.bulletsP.add(bullet); // add the bullet to the list
               									// of Bullets
                  add(bullet); // add the bullet to the screen
               }
            }
         }
      
         public void createWindow(Game obj) {// (Space_invadors obj){
         
            //frame = new JFrame();
            setTitle("Spaceeeeeeeeeeeeeeeee Invaders");
            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            setSize(800, 800);
            setResizable(false);
            setLocation(autoDim.width / 2 - getSize().width / 2,autoDim.height / 2 - getSize().height / 2);
            setFocusable(true);
            //add(obj);
            setVisible(true);
         }
      
         public void gameRun(ImageIcon player, ImageIcon enemy, ImageIcon obstacles) {
         
            //Game obj = new Game(player, enemy, obstacles);
            //createWindow(obj);
            
            createWindow(gameObj);
            /*
            while(true){
               obj.moveObjects();
               obj.enemyShoot();
               obj.anyHit();
               try {Thread.sleep(20);} 
               catch (Exception e) {e.printStackTrace();}
               obj.repaint();
            }*/
            /*
            while(true){
               gameObj.moveObjects();
               gameObj.enemyShoot();
               gameObj.anyHit();
               try {Thread.sleep(20);} 
               catch (Exception e) {e.printStackTrace();}
               gameObj.repaint();
            }*/
         }
      }
   
      public static void main(String[] args) {
      
      	// Improving the basic java look and feel:
      	// DO NOT MOVE IT TO SOMEWHERE ELSE
         try {UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());} 
         catch (Exception e){e.printStackTrace();}
      
         mainClip.loop();
      
         new Space_invadors();
      }
   }
   
   
   
   
   version 2:
   
   import java.awt.event.ActionEvent;
   import java.awt.event.ActionListener;
   import java.awt.Graphics;
   import java.awt.Image;
   import java.awt.event.KeyEvent;
   import java.awt.event.KeyListener;
   import java.awt.Dimension;
   import java.awt.Toolkit;
   import java.awt.*;
   
   import java.util.Iterator;
   import javax.swing.ImageIcon;
   import javax.swing.JFrame;
   import javax.swing.JOptionPane;
   import javax.swing.JPanel;
   import javax.swing.JButton;
   import javax.swing.*;
   
   import java.applet.Applet;
   import java.applet.AudioClip;
   import java.net.URL;
   
   public class Space_invadors{// extends JFrame{
   
      private static JFrame mainWindow = new JFrame(); 
      
   	// The background sound for the game:
      private static URL mainURL = Space_invadors.class.getResource("backSound.wav");
      private static AudioClip mainClip = Applet.newAudioClip(mainURL);
   
      //An object to the Game class:
      private Game gameObj = new Game(null, null, null); 
      
      //A panel for the player menue:
      private JPanel menuePanel; 
      
      //Centering the JFrame:
      private final static Dimension auotDim = Toolkit.getDefaultToolkit().getScreenSize();
      
      public Space_invadors(){
      
         //System.out.println(javax.swing.SwingUtilities.isEventDispatchThread());
         
         //Creating the window:
         frameCreate();
         
         //Calling the player menue:
         new StartMenus();
         
         //Game t = new Game(null,null,null);
         //t.gameRun(null,null,null);
         
         //gameObj.gameRun(null,null,null);
      }
      
      private void frameCreate(){
      
         mainWindow.setTitle("Space Invaders");
         mainWindow.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
         mainWindow.setSize(800, 800);
         mainWindow.setResizable(false);
         mainWindow.setLocation(auotDim.width / 2 - mainWindow.getSize().width / 2, auotDim.height / 2 - mainWindow.getSize().height / 2);
         mainWindow.setLayout(new GridLayout(0, 1));
         //setVisible(false); <-- By default it's false
      }
   
      private class StartMenus implements ActionListener{
            
         URL[] players = { Space_invadors.class.getResource("menuePlayer1.png"),
                     		Space_invadors.class.getResource("menuePlayer2.png"),
                     		Space_invadors.class.getResource("menuePlayer3.png"),
                     		Space_invadors.class.getResource("menuePlayer4.png") };
                           
         JButton[] playerButtons = {new JButton("Blue Knight", new ImageIcon(players[0])),
                              		new JButton("Terminator",  new ImageIcon(players[1])),
                              		new JButton("Red Eagle",   new ImageIcon(players[2])),
                              		new JButton("Phantom",     new ImageIcon(players[3])), 
                                    new JButton("DEFAULT")};
      
         public StartMenus() {
         
         	// Menu one - Introduction:
            JLabel welcome = new JLabel("Hello player and wellcome! \n" + 
                                        "Please choose your desired spaceship from the following menue!");
            welcome.setFont(new Font("Arial", Font.BOLD, 18));
            JOptionPane.showMessageDialog(null, welcome, "WELCOME", JOptionPane.WARNING_MESSAGE);
            
            //Panel one for the player menu:
            menuePanel = new JPanel(new GridLayout(0, 1)); 
            
         	// Setting the color of each button:
            for (JButton x : playerButtons) {
            
               x.setFont(new Font(Font.SANS_SERIF, Font.BOLD, 50));
            
               if (x == playerButtons[0])
                  playerButtons[0].setForeground(Color.BLUE);
               else if (x == playerButtons[1])
                  playerButtons[1].setForeground(Color.YELLOW);
               else if (x == playerButtons[2])
                  playerButtons[2].setForeground(Color.RED);
               else if (x == playerButtons[3])
                  playerButtons[3].setForeground(Color.GRAY);
               else
                  playerButtons[4].setForeground(Color.BLACK);
            
               //Add the bttons to the panel:
               menuePanel.add(x);
            }
         
         	// Assigning actionListener to each buttom
            for(int i = 0; i < 5; i++){
               playerButtons[i].addActionListener(this);
            }
            
            //Adding the panel to the JFrame and make the JFrame visible:     
            mainWindow.add(menuePanel);
            mainWindow.setVisible(true);
         }
         
         public void actionPerformed(ActionEvent e){
         
            //mainWindow.dispose();
            mainWindow.setVisible(false);
                     
            if (e.getActionCommand() == "Blue Knight")
               gameObj.gameRun(new ImageIcon(players[0]), null, null);
            else if (e.getActionCommand() == "Terminator")
               gameObj.gameRun(new ImageIcon(players[1]), null, null);
            else if (e.getActionCommand() == "Red Eagle")
               gameObj.gameRun(new ImageIcon(players[2]), null, null);
            else if (e.getActionCommand() == "Phantom")
               gameObj.gameRun(new ImageIcon(players[3]), null, null);
            else//Default
               gameObj.gameRun(null, null, null);
         }
      }
   
      private class Game extends JPanel implements KeyListener {
      
      	// JProgressBar prg; 
         
         private Image background;
      	// private ImageIcon deadMeat = new ImageIcon(this.getClass().getResource("Explosion.png")); // Add the explosion!!!!
         
         private static final int NUM_OF_TARGETS_COL = 10;// Can't be less than 10
         private static final int NUM_OF_TARGETS_ROW = 3;
         private static final int NUM_OF_OBSTACLES = 7;
      
         private int targetsVelocity = 0; // initial velocity of targets
         private int TARGET_LIVES = 1; // minimum life for the target
         private int TARGET_SPEED = 1; // minimum speed for the target
         // 2D array to hold more than 1 row of enemy:
         private Target[][] targets = new Target[NUM_OF_TARGETS_ROW][NUM_OF_TARGETS_COL]; 
      
         private Player player;
         private int PLAYER_LIVES = 3; // minimum life for the player
      
         private Obstacle[] obstacles = new Obstacle[NUM_OF_OBSTACLES];
      
         private boolean isAnyAlive = false; // Used with the player's bullets to determine if they are excited on the screen
         private boolean isAnyAliveEnemyBullets = false; // Used for the enemy's bullets
         private boolean enemyAlive = false; // If the player didn't kill all the targets then a different menue will be shown
      
         private URL enemyDie = Space_invadors.class.getResource("enemyDying.wav");
         private URL playerDie = Space_invadors.class.getResource("playerDying.wav");
         private URL enemyS = Space_invadors.class.getResource("enemyShoot.wav");
         private URL playerS = Space_invadors.class.getResource("playerShoot.wav");
         private AudioClip enemyClip = Applet.newAudioClip(enemyDie);
         private AudioClip playerClip = Applet.newAudioClip(playerDie);
         private AudioClip enemyShoot = Applet.newAudioClip(enemyS);
         private AudioClip playerShoot = Applet.newAudioClip(playerS);
      
         private JComboBox optionsMenue;
         private URL mainURL = Space_invadors.class.getResource("backSound.wav");
         private AudioClip mainClip = Applet.newAudioClip(mainURL);
      
         //private final Dimension autoDim = Toolkit.getDefaultToolkit().getScreenSize();
      
         public int change = 0;
      
      	/**
      	 * The constractor of the class will instantiate the obstacle, target,
      	 * Bullet and the player classes in order to create full functioning
      	 * game. Also, will create a new object for the background image.
      	 * 
      	 * @param obstaclesIcon
      	 *            - Passing an image parameter to replace the default one
      	 *            for the obstacle view.
      	 * @param enemyIcon
      	 *            - Passing an image parameter to replace the default one
      	 *            for the enemy view.
      	 * @param playerIcon
      	 *            - Passing an image parameter to replace the default one
      	 *            for the player view.
      	 */
         public Game(ImageIcon playerIcon, ImageIcon enemyIcon, ImageIcon obstaclesIcon) {
            
         	// enemyDie = Space_invadors.class.getResource("Dying1.wav");
         	// enemyClip = Applet.newAudioClip(enemyDie);
         	/*
         	 * prg = new JProgressBar(0,100); prg.setValue(100);
         	 * prg.setStringPainted(true); prg.setEnabled(true); add(prg);
         	 * //prg.setString("100");
         	 */
         
         	// Add the background:
            background = new ImageIcon(getClass().getResource("BackGray.jpg")).getImage();
            
         	// Creates obstacles
            int obstacleX = 25, lives = 5; // each brick has 5 lives
            for (int i = 0; i < obstacles.length; i++, obstacleX += 100) {
            
               if (obstaclesIcon == null)
                  obstacles[i] = new Obstacle(null, obstacleX + 50, 500, lives);
               else
                  obstacles[i] = new Obstacle(obstaclesIcon.getImage(), obstacleX + 50, 500, lives);
            
               add(obstacles[i]);
            }
         
         	// Create targets
            int targetX = 0, targetY = 50;
         
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++, targetX += 50) {
               
                  if (enemyIcon == null)
                     targets[a][i] = new Target(null, targetX, targetY, TARGET_LIVES);
                  else
                     targets[a][i] = new Target(enemyIcon.getImage(), targetX, targetY, TARGET_LIVES);
               
                  add(targets[a][i]);
               }
            
               targetY += 50;
               targetX = 0;
            }
         
         	// Create the player:
            if (playerIcon == null)
               player = new Player(null, 350, 650, PLAYER_LIVES, 0);
            else
               player = new Player(playerIcon.getImage(), 350, 650, PLAYER_LIVES, 0);
         
            add(player); // Adds player to the panel
            
            //this.addKeyListener(this); // Adds keyListener to the panel <====================
            addKeyListener(this); // Adds keyListener to the panel
         }
      
      	/**
      	 * The paint method is used to paint an object as a graphical user
      	 * interface. The paintComponent method will be called from the repaint
      	 * method.
      	 * 
      	 * @param g
      	 *            - The specified graphic object to paint in the window
      	 *            (self-customize one)
      	 */
         @Override
         protected synchronized void paintComponent(Graphics g) {
         
         	// The background of the window will be drawn manually, therefore no
         	// need for:
         	// super.paintComponent(g); //Passes the graphics context off to the
         	// component's UI delegate, which paints the panel's background
         
            g.drawImage(background, 0, 0, getWidth(), getHeight(), null);
         
            player.drawPlayer(g); // draws player on the screen
         
            for (int i = 0; i < obstacles.length; i++)
               obstacles[i].drawObstacles(g); // draws obstacles on the screen
         
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) { // draws targets on
            												// the screen
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
               
                  targets[a][i].drawTarget(g);
               
               	// Drawing the bullets for the enemy:
                  for (Iterator<Bullet> it = targets[a][i].bulletsE.iterator(); it
                  		.hasNext();/* NO arg */) {
                  
                     Bullet temp = it.next();
                     temp.drawBullet(g);
                  }
               }
            }
         
         	// Drawing the bullets for the player:
            for (Iterator<Bullet> it = player.bulletsP.iterator(); it.hasNext();) {// bullets.iterator()
               Bullet b = it.next();
               b.drawBullet(g); // draws player bullets on the screen from the
            						// Player class
            }
         
            g.dispose();// if i cancel that line there are gray squers on top
         				// for some reason
         }
      
      	/**
      	 * moveObjects method is used to move the objects on the screen, in this
      	 * case the objects are the bullets/targets. The method will not paint
      	 * the objects, it will only move them to a different location on the
      	 * panel.
      	 */
         public void moveObjects() {
         
         /*Creating a local variable to direct the enemy on the y-value, 
           after the enemy reached every edge, it will go down ten levels:*/
            int moveY = 0;
         
         	/*
         	 * The interface Iterator<E> is a linked list that takes a type
         	 * Bullet (from the Bullet class) and iterate among the elements
         	 * inside the linked list that the Bullet class has. E - The type of
         	 * elements returned by this iterator (Bullet object)
         	 * 
         	 * The "it" is a pointer pointing to the head of the list and as
         	 * long that .iterator returns another element the for loop will
         	 * continue
         	 */
         	// Moving the player bullets:
            for (Iterator<Bullet> it = player.bulletsP.iterator(); it.hasNext();/* NO arg */) {
            
               Bullet tempBullet = it.next(); // pull out a Bullet objects from the list; 1 each time
               isAnyAlive = tempBullet.isAlive ? true : false;
               tempBullet.y = tempBullet.y - 13; // move the bullet 13 pixels up each repaint()
            }
         
         	// ----------------------------------------------------------------------------------------------------------------------------------
         	// Check if the targets got to either one of the sides:
            if (targets[0][NUM_OF_TARGETS_COL - 1].x == 750) { // targets move
            													// in relation
            													// to the far
            													// right target
               targetsVelocity = -1 * TARGET_SPEED; // targets move left
               moveY = 10; // targets go down one row
            } 
            else if (targets[0][NUM_OF_TARGETS_COL - 1].x == 450) { // targets
            															// move
            															// in
            															// relation
            															// to
            															// the
            															// far
            															// left
            															// target
               targetsVelocity = TARGET_SPEED; // targets move right
               moveY = 10; // targets go down one row
            }
         	// ----------------------------------------------------------------------------------------------------------------------------------
         
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
               
               	// ---------------------------------------------------------------------------------------
                  for (Iterator<Bullet> it = targets[a][i].bulletsE.iterator(); it
                  		.hasNext();/* NO arg */) {
                  
                     Bullet temp = it.next();
                     isAnyAliveEnemyBullets = temp.isAlive ? true : false;
                     temp.y += 6;
                  }
               	// ---------------------------------------------------------------------------------------
               
                  targets[a][i].x = targets[a][i].x + targetsVelocity; // move
               															// the
               															// targets
               															// to
               															// either
               															// left
               															// or
               															// right
                  targets[a][i].y = targets[a][i].y + moveY; // move the
               												// targets down
               }
            }
         }
      
      	/**
      	 * The anyHit method measuring the bullet and the target x and y axis to
      	 * report if ther's a hit or not.
      	 */
         public synchronized void anyHit() { // compares each bullet x,y to each target x,y
         
         	// -----------------------------THE PLAYER BULLET-------------------------------------------
            for (Iterator<Bullet> it = player.bulletsP.iterator(); it.hasNext(); /* NO args */) {
            
               Bullet tempBullet = it.next(); // pulling out 1 bullet object
            									// from the list at a time
            
               if (tempBullet.isAlive) { // if bullet is still on the screen
               	// Check the position of the bullet corresponding to the
               	// target:
                  for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
                  
                     for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
                     
                        if (targets[a][i].isAlive) { // If the enemy is
                        								// still in the game
                        
                           boolean hit = false;
                        
                        	// Checking for matching locations:
                           if (tempBullet.x >= targets[a][i].x && tempBullet.x <= targets[a][i].x + 50
                           		&& tempBullet.y >= targets[a][i].y && tempBullet.y <= targets[a][i].y + 50)
                              hit = true; // If there is a hit then the
                        					// variable will be change to
                        					// true
                        
                           if (hit) {// If the bullet hit the target:
                              tempBullet.isAlive = false;// The bullet is
                           								// deleted from
                           								// the screen
                           
                              if (targets[a][i].lives > 0) {// If the
                              								// target
                              								// had more
                              								// than 0,
                              								// subtract
                              								// 1
                                 targets[a][i].lives -= 1;
                              }
                              if (targets[a][i].lives == 0) {// if target
                              								// has 0
                              								// lives,
                              								// delete
                              								// the icon
                              								// from the
                              								// screen
                                 targets[a][i].isAlive = false;
                                 enemyClip.play();
                              }
                           }
                        }
                     
                        if (tempBullet.isAlive && tempBullet.y <= 0) // if
                        												// bullet
                        												// flew
                        												// off
                        												// the
                        												// screen
                        												// without
                        												// hitting
                        												// any
                        												// targets
                           tempBullet.isAlive = false;
                     }
                  }
               
               	// Check the position of the bullet corresponding to the
               	// obstacle:
                  for (int i = 0; i < obstacles.length; i++) {
                  
                     boolean hit = false;
                  
                     if (obstacles[i].isAlive) {
                     
                        if (tempBullet.x >= obstacles[i].x && tempBullet.x <= obstacles[i].x + 55
                        		&& tempBullet.y >= obstacles[i].y && tempBullet.y <= obstacles[i].y + 30)
                        
                           hit = true;
                     
                        if (hit) {
                           tempBullet.isAlive = false;
                           obstacles[i].lives -= 1; // reduces the brick
                        								// life by 1;
                        }
                        if (obstacles[i].lives == 0) {
                           obstacles[i].isAlive = false; // brick dies
                        									// after 5 hits
                        }
                     }
                  }
               }
            }
         
         	// -----------------------------THE ENEMY BULLET-------------------------------------------
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
               
                  for (Iterator<Bullet> it = targets[a][i].bulletsE.iterator(); it.hasNext();/* NO arg */) {
                  
                  	// Checking the position of the BULLET of EACH ENEMY:
                  
                     Bullet temp = it.next();
                  
                     if (temp.isAlive) {
                     
                        boolean hit = false;
                     
                     	// Check if one of the bullets of the enemy match
                     	// the location of the player:
                        if (temp.x >= player.x && temp.x <= player.x + 50 && temp.y >= player.y
                        		&& temp.y <= player.y + 50) {
                           hit = true;
                        }
                        if (hit) {// If the bullet hit the Player:
                           temp.isAlive = false;// The enemy's bullet is deleted from the screen
                        
                           if (player.lives > 0) {// If the Player had more than 0, subtract 1
                              player.lives -= 1;
                           }
                        }
                     }
                  
                  	// If there was no hit:
                     if (temp.isAlive && temp.y >= 800){ //if bullet flew off the screen without hitting any targets
                        isAnyAliveEnemyBullets = false;// ?????????????????????? NOT SURE!!!!!!!!!!!!!!!!
                        temp.isAlive = false;
                     }
                  }
               }
            }
         }
      
         boolean isGameOver() { // Checks if alive targets are left
         
            boolean gameOver = true;
         
            Dead: for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
               
                  if (targets[a][i].isAlive) {
                     gameOver = false;
                  
                  	// If the player didn't kill all the targets he/she
                  	// automatically lose
                     if (targets[a][i].y == 500) {
                     
                        gameOver = true;
                        enemyAlive = true;
                     
                        playerClip.play();
                     
                        break Dead;
                     }
                  }
               }
            }
         
         	// ADD HERE THE CASE WHEN THE USER GOT KILLED BY THE ENEMY
            if (player.lives == 0) {
               playerClip.play();
               JOptionPane.showMessageDialog(null, "YOU'RE A DEAD MEAT!!!");
            
               gameOver = true;
            }
         
            return gameOver;
         }
      
         public void enemyShoot() {
         
            //synchronized(this){
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
               
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
                  
                  // if there is an enemy at the corrent location AND there
                  // is no bullets on the screen from the enemy then:
                  if (targets[a][i].isAlive && !isAnyAliveEnemyBullets) {
                     enemyShoot.play();
                     // Releases a bullet from where the player currently is:
                     Bullet enemyBullet = new Bullet(targets[a][i].x + 10, targets[a][i].y + 35, 1);
                      // Add the bullet to the list of Bullets:
                     targets[a][i].bulletsE.add(enemyBullet); 
                     // Add the bullet to the screen:
                     add(enemyBullet); 
                  }
               }
            }
            //}
         }
      
         public void startMenue() {
         
         	// JOptionPane to inform about selcting the level"
            JLabel difficulty = new JLabel("Please choose a level of dificulty from the menue");
            difficulty.setFont(new Font("Arial", Font.BOLD, 18));
            JOptionPane.showMessageDialog(null, difficulty, "DIFFICULTY", JOptionPane.WARNING_MESSAGE);
         
         	// Create the options for the player:
            String[] options = { "Grandma (Easy)", "Player (Mid)", "KILL ZONE (Hard)" };
            JComboBox optionsMenue = new JComboBox(options);
            optionsMenue.setEditable(false);
            JOptionPane.showMessageDialog(null, optionsMenue, "SELECT YOUR LEVEL!", JOptionPane.QUESTION_MESSAGE);
         
         	// Adjust the difficulty accordingly:
            switch (optionsMenue.getSelectedIndex()) {
            
               case 0:// Easy
                  {
                     TARGET_LIVES = 1;
                     TARGET_SPEED = 1;
                     break;
                  }
               case 1:// Mid
                  {
                     TARGET_LIVES = 2;
                     TARGET_SPEED = 2;
                     break;
                  }
               case 2:// Hard
                  {
                     TARGET_LIVES = 3;
                     TARGET_SPEED = 3;
                     break;
                  }
            }
         	// return optionsMenue;
         }
      
         @Override public void keyTyped(KeyEvent e) {/* not in use */}
         @Override public void keyReleased(KeyEvent e) {/* not in use */}
         @Override public void keyPressed(KeyEvent e) {
         
            int code = e.getKeyCode();
         
            if (code == KeyEvent.VK_RIGHT) {
            
               if (!(player.x >= 700)) {
                  player.x = player.x + 10;
               }
            }
            
            else if (code == KeyEvent.VK_LEFT) {
            
               if (!(player.x <= 0)) {
                  player.x = player.x - 10;
               }
            }
            
            else if (code == KeyEvent.VK_SPACE) { // releases a bullet each time
            										// SPACE pressed
            
               if (!isAnyAlive) { // Checks that there is no bullets in the
               					// screen before shooting new one
                  playerShoot.play();
                  Bullet bullet = new Bullet(player.x + 29, player.y + 0, 0); // Releases
               																// a
               																// bullet
               																// from
               																// where
               																// the
               																// player
               																// currently
               																// is
                  player.bulletsP.add(bullet); // add the bullet to the list
               									// of Bullets
                  add(bullet); // add the bullet to the screen
               }
            }
         }
          
          /*
         public void createWindow(Game obj) {// (Space_invadors obj){
         
            //frame = new JFrame();
            setTitle("Spaceeeeeeeeeeeeeeeee Invaders");
            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            setSize(800, 800);
            setResizable(false);
            setLocation(autoDim.width / 2 - getSize().width / 2,autoDim.height / 2 - getSize().height / 2);
            setFocusable(true);
            //add(obj);
            setVisible(true);
         }*/
      
         public void gameRun(ImageIcon player, ImageIcon enemy, ImageIcon obstacles) {
         
            mainWindow.getContentPane().remove(menuePanel);
            
            
            mainWindow.add(gameObj);
            mainWindow.setVisible(true);
            
            //createWindow(gameObj);
            /*
            while(true){
               obj.moveObjects();
               obj.enemyShoot();
               obj.anyHit();
               try {Thread.sleep(20);} 
               catch (Exception e) {e.printStackTrace();}
               obj.repaint();
            }*/
            /*
            while(true){
               gameObj.moveObjects();
               gameObj.enemyShoot();
               gameObj.anyHit();
               try {Thread.sleep(20);} 
               catch (Exception e) {e.printStackTrace();}
               gameObj.repaint();
            }*/
         }
      }
   
      public static void main(String[] args) {
      
      	// Improving the basic java look and feel:
      	// DO NOT MOVE IT TO SOMEWHERE ELSE
         try {UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());} 
         catch (Exception e){e.printStackTrace();}
      
         mainClip.loop();
      
         new Space_invadors();
      }
   }
   
   
   
   version 3:
      /**
    * © All rights reserved for Alon Butbul, a copy and/or implementing of that class or any other class in this 
    * project without a written consent from Alon Butbul, will results in a serious issue 
    * and will lead to further actions in court. 
    * 
    * @author Alon Butbul 
    * @version 1.0
    * 
    * 
    * The Space_invadors class is used to create a game in which the user will be able to 
    * interact with the program using the java GUI interface.
    * 
    * That particular class extending and implementing other classes such as JFrame or KeyListener, <--------- OR?????
    * to construct a full functioning interactive game.
    * */
   
   import java.awt.event.ActionEvent;
   import java.awt.event.ActionListener;
   import java.awt.Graphics;
   import java.awt.Image;
   import java.awt.event.KeyEvent;
   import java.awt.event.KeyListener;
   import java.awt.Dimension;
   import java.awt.Toolkit;
   import java.awt.*;
   
   import java.util.Iterator;
   import javax.swing.ImageIcon;
   import javax.swing.JFrame;
   import javax.swing.JOptionPane;
   import javax.swing.JPanel;
   import javax.swing.JButton;
   import javax.swing.*;
   
   import java.applet.Applet;
   import java.applet.AudioClip;
   import java.net.URL;
   
   public class Space_invadors{
   
      private static JFrame mainWindow = new JFrame(); 
      
   	// The background sound for the game:
      private static URL mainURL = Space_invadors.class.getResource("backSound.wav");
      private static AudioClip mainClip = Applet.newAudioClip(mainURL);
   
      //An object to the Game class:
      private Game gameObj = new Game(null, null, null); 
      
      //A panel for the player menue:
      //private JPanel menuePanel; 
      
      //Centering the JFrame:
      //private final static Dimension auotDim = Toolkit.getDefaultToolkit().getScreenSize();
      
      public Space_invadors(){
      
         //System.out.println(javax.swing.SwingUtilities.isEventDispatchThread());
         
         //Creating the window:
         frameCreate();
         
         //Calling the player menue:
         new StartMenus();
         
         //gameObj.gameRun(null,null,null);
      }
      
      private void frameCreate(){
      
         mainWindow.setTitle("Space Invaders");
         mainWindow.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
         mainWindow.setSize(800, 800);
         mainWindow.setResizable(false);
         //mainWindow.setLocation(auotDim.width / 2 - mainWindow.getSize().width / 2, auotDim.height / 2 - mainWindow.getSize().height / 2);
         mainWindow.setLocationRelativeTo(null);
         mainWindow.setLayout(new GridLayout(0, 1));
         //setVisible(false); <-- By default it's false
      }
   
      private class StartMenus extends JPanel implements ActionListener{
            
         URL[] players = { Space_invadors.class.getResource("menuePlayer1.png"),
                     		Space_invadors.class.getResource("menuePlayer2.png"),
                     		Space_invadors.class.getResource("menuePlayer3.png"),
                     		Space_invadors.class.getResource("menuePlayer4.png") };
                           
         JButton[] playerButtons = {new JButton("Blue Knight", new ImageIcon(players[0])),
                              		new JButton("Terminator",  new ImageIcon(players[1])),
                              		new JButton("Red Eagle",   new ImageIcon(players[2])),
                              		new JButton("Phantom",     new ImageIcon(players[3])), 
                                    new JButton("DEFAULT")};
      
         public StartMenus() {
         
         	// Menu one - Introduction:
            JLabel welcome = new JLabel("Hello player and wellcome! \n" + 
                                        "Please choose your desired spaceship from the following menue!");
            welcome.setFont(new Font("Arial", Font.BOLD, 18));
            JOptionPane.showMessageDialog(null, welcome, "WELCOME", JOptionPane.WARNING_MESSAGE);
            
            //Panel one for the player menu:
            menuePanel = new JPanel(new GridLayout(0, 1)); 
            
         	// Setting the color of each button:
            for (JButton x : playerButtons) {
            
               x.setFont(new Font(Font.SANS_SERIF, Font.BOLD, 50));
            
               if (x == playerButtons[0])
                  playerButtons[0].setForeground(Color.BLUE);
               else if (x == playerButtons[1])
                  playerButtons[1].setForeground(Color.YELLOW);
               else if (x == playerButtons[2])
                  playerButtons[2].setForeground(Color.RED);
               else if (x == playerButtons[3])
                  playerButtons[3].setForeground(Color.GRAY);
               else
                  playerButtons[4].setForeground(Color.BLACK);
            
               //Add the bttons to the panel:
               menuePanel.add(x);
            }
         
         	// Assigning actionListener to each buttom
            for(int i = 0; i < 5; i++){
               playerButtons[i].addActionListener(this);
            }
            
            //Adding the panel to the JFrame and make the JFrame visible:     
            mainWindow.getContentPane().add(menuePanel);
            mainWindow.setVisible(true);
         }
         
         public void actionPerformed(ActionEvent e){
         
            //mainWindow.dispose();
            mainWindow.setVisible(false);
                     
            if (e.getActionCommand() == "Blue Knight")
               gameObj.gameRun(new ImageIcon(players[0]), null, null);
            else if (e.getActionCommand() == "Terminator")
               gameObj.gameRun(new ImageIcon(players[1]), null, null);
            else if (e.getActionCommand() == "Red Eagle")
               gameObj.gameRun(new ImageIcon(players[2]), null, null);
            else if (e.getActionCommand() == "Phantom")
               gameObj.gameRun(new ImageIcon(players[3]), null, null);
            else//Default
               gameObj.gameRun(null, null, null);
         }
      }
   
      private class Game extends JPanel implements KeyListener {
      
      	// JProgressBar prg; 
         
         private Image background;
      	// private ImageIcon deadMeat = new ImageIcon(this.getClass().getResource("Explosion.png")); // Add the explosion!!!!
         
         private static final int NUM_OF_TARGETS_COL = 10;// Can't be less than 10
         private static final int NUM_OF_TARGETS_ROW = 3;
         private static final int NUM_OF_OBSTACLES = 7;
      
         private int targetsVelocity = 0; // initial velocity of targets
         private int TARGET_LIVES = 1; // minimum life for the target
         private int TARGET_SPEED = 1; // minimum speed for the target
         // 2D array to hold more than 1 row of enemy:
         private Target[][] targets = new Target[NUM_OF_TARGETS_ROW][NUM_OF_TARGETS_COL]; 
      
         private Player player;
         private int PLAYER_LIVES = 3; // minimum life for the player
      
         private Obstacle[] obstacles = new Obstacle[NUM_OF_OBSTACLES];
      
         private boolean isAnyAlive = false; // Used with the player's bullets to determine if they are excited on the screen
         private boolean isAnyAliveEnemyBullets = false; // Used for the enemy's bullets
         private boolean enemyAlive = false; // If the player didn't kill all the targets then a different menue will be shown
      
         private URL enemyDie = Space_invadors.class.getResource("enemyDying.wav");
         private URL playerDie = Space_invadors.class.getResource("playerDying.wav");
         private URL enemyS = Space_invadors.class.getResource("enemyShoot.wav");
         private URL playerS = Space_invadors.class.getResource("playerShoot.wav");
         private AudioClip enemyClip = Applet.newAudioClip(enemyDie);
         private AudioClip playerClip = Applet.newAudioClip(playerDie);
         private AudioClip enemyShoot = Applet.newAudioClip(enemyS);
         private AudioClip playerShoot = Applet.newAudioClip(playerS);
      
         private JComboBox optionsMenue;
         private URL mainURL = Space_invadors.class.getResource("backSound.wav");
         private AudioClip mainClip = Applet.newAudioClip(mainURL);
      
         //private final Dimension autoDim = Toolkit.getDefaultToolkit().getScreenSize();
      
         public int change = 0;
      
      	/**
      	 * The constractor of the class will instantiate the obstacle, target,
      	 * Bullet and the player classes in order to create full functioning
      	 * game. Also, will create a new object for the background image.
      	 * 
      	 * @param obstaclesIcon - Passing an image parameter to replace the default one
      	 *  for the obstacle view.
      	 * @param enemyIcon - Passing an image parameter to replace the default one
      	 *  for the enemy view.
      	 * @param playerIcon - Passing an image parameter to replace the default one
      	 *  for the player view.
      	 */
         public Game(ImageIcon playerIcon, ImageIcon enemyIcon, ImageIcon obstaclesIcon) {
            
         	// enemyDie = Space_invadors.class.getResource("Dying1.wav");
         	// enemyClip = Applet.newAudioClip(enemyDie);
         	/*
         	 * prg = new JProgressBar(0,100); prg.setValue(100);
         	 * prg.setStringPainted(true); prg.setEnabled(true); add(prg);
         	 * //prg.setString("100");
         	 */
         
         	// Add the background:
            background = new ImageIcon(getClass().getResource("BackGray.jpg")).getImage();
            
         	// Creates obstacles
            int obstacleX = 25, lives = 5; // each brick has 5 lives
            for (int i = 0; i < obstacles.length; i++, obstacleX += 100) {
            
               if (obstaclesIcon == null)
                  obstacles[i] = new Obstacle(null, obstacleX + 50, 500, lives);
               else
                  obstacles[i] = new Obstacle(obstaclesIcon.getImage(), obstacleX + 50, 500, lives);
            
               add(obstacles[i]);
            }
         
         	// Create targets
            int targetX = 0, targetY = 50;
         
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++, targetX += 50) {
               
                  if (enemyIcon == null)
                     targets[a][i] = new Target(null, targetX, targetY, TARGET_LIVES);
                  else
                     targets[a][i] = new Target(enemyIcon.getImage(), targetX, targetY, TARGET_LIVES);
               
                  add(targets[a][i]);
               }
            
               targetY += 50;
               targetX = 0;
            }
         
         	// Create the player:
            if (playerIcon == null)
               player = new Player(null, 350, 650, PLAYER_LIVES, 0);
            else
               player = new Player(playerIcon.getImage(), 350, 650, PLAYER_LIVES, 0);
         
            add(player); // Adds player to the panel
            
            this.addKeyListener(this); // Adds keyListener to the panel
            
            this.setFocusable(true);
         }
      
      	/**
      	 * The paint method is used to paint an object as a graphical user
      	 * interface. The paintComponent method will be called from the repaint
      	 * method.
      	 * 
      	 * @param g
      	 *            - The specified graphic object to paint in the window
      	 *            (self-customize one)
      	 */
         @Override
         protected void paintComponent(Graphics g) {
         
         	// The background of the window will be drawn manually, therefore no
         	// need for:
         	// super.paintComponent(g); //Passes the graphics context off to the
         	// component's UI delegate, which paints the panel's background
         
            g.drawImage(background, 0, 0, getWidth(), getHeight(), null);
         
            player.drawPlayer(g); // draws player on the screen
         
            for (int i = 0; i < obstacles.length; i++)
               obstacles[i].drawObstacles(g); // draws obstacles on the screen
         
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) { // draws targets on
            												// the screen
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
               
                  targets[a][i].drawTarget(g);
               
               	// Drawing the bullets for the enemy:
                  for (Iterator<Bullet> it = targets[a][i].bulletsE.iterator(); it
                  		.hasNext();/* NO arg */) {
                  
                     Bullet temp = it.next();
                     temp.drawBullet(g);
                  }
               }
            }
         
         	// Drawing the bullets for the player:
            for (Iterator<Bullet> it = player.bulletsP.iterator(); it.hasNext();) {// bullets.iterator()
               Bullet b = it.next();
               b.drawBullet(g); // draws player bullets on the screen from the
            						// Player class
            }
         
            g.dispose();// if i cancel that line there are gray squers on top
         				// for some reason
         }
      
      	/**
      	 * moveObjects method is used to move the objects on the screen, in this
      	 * case the objects are the bullets/targets. The method will not paint
      	 * the objects, it will only move them to a different location on the
      	 * panel.
      	 */
         public void moveObjects() {
         
         /*Creating a local variable to direct the enemy on the y-value, 
           after the enemy reached every edge, it will go down ten levels:*/
            int moveY = 0;
         
         	/*
         	 * The interface Iterator<E> is a linked list that takes a type
         	 * Bullet (from the Bullet class) and iterate among the elements
         	 * inside the linked list that the Bullet class has. E - The type of
         	 * elements returned by this iterator (Bullet object)
         	 * 
         	 * The "it" is a pointer pointing to the head of the list and as
         	 * long that .iterator returns another element the for loop will
         	 * continue
         	 */
         	// Moving the player bullets:
            for (Iterator<Bullet> it = player.bulletsP.iterator(); it.hasNext();/* NO arg */) {
            
               Bullet tempBullet = it.next(); // pull out a Bullet objects from the list; 1 each time
               isAnyAlive = tempBullet.isAlive ? true : false;
               tempBullet.y = tempBullet.y - 13; // move the bullet 13 pixels up each repaint()
            }
         
         	// ----------------------------------------------------------------------------------------------------------------------------------
         	// Check if the targets got to either one of the sides:
            if (targets[0][NUM_OF_TARGETS_COL - 1].x == 750) { // targets move
            													// in relation
            													// to the far
            													// right target
               targetsVelocity = -1 * TARGET_SPEED; // targets move left
               moveY = 10; // targets go down one row
            } 
            else if (targets[0][NUM_OF_TARGETS_COL - 1].x == 450) { // targets
            															// move
            															// in
            															// relation
            															// to
            															// the
            															// far
            															// left
            															// target
               targetsVelocity = TARGET_SPEED; // targets move right
               moveY = 10; // targets go down one row
            }
         	// ----------------------------------------------------------------------------------------------------------------------------------
         
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
               
               	// ---------------------------------------------------------------------------------------
                  for (Iterator<Bullet> it = targets[a][i].bulletsE.iterator(); it
                  		.hasNext();/* NO arg */) {
                  
                     Bullet temp = it.next();
                     isAnyAliveEnemyBullets = temp.isAlive ? true : false;
                     temp.y += 6;
                  }
               	// ---------------------------------------------------------------------------------------
               
                  targets[a][i].x = targets[a][i].x + targetsVelocity; // move
               															// the
               															// targets
               															// to
               															// either
               															// left
               															// or
               															// right
                  targets[a][i].y = targets[a][i].y + moveY; // move the
               												// targets down
               }
            }
         }
      
      	/**
      	 * The anyHit method measuring the bullet and the target x and y axis to
      	 * report if ther's a hit or not.
      	 */
         public void anyHit() { // compares each bullet x,y to each target x,y
         
         	// -----------------------------THE PLAYER BULLET-------------------------------------------
            for (Iterator<Bullet> it = player.bulletsP.iterator(); it.hasNext(); /* NO args */) {
            
               Bullet tempBullet = it.next(); // pulling out 1 bullet object
            									// from the list at a time
            
               if (tempBullet.isAlive) { // if bullet is still on the screen
               	// Check the position of the bullet corresponding to the
               	// target:
                  for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
                  
                     for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
                     
                        if (targets[a][i].isAlive) { // If the enemy is
                        								// still in the game
                        
                           boolean hit = false;
                        
                        	// Checking for matching locations:
                           if (tempBullet.x >= targets[a][i].x && tempBullet.x <= targets[a][i].x + 50
                           		&& tempBullet.y >= targets[a][i].y && tempBullet.y <= targets[a][i].y + 50)
                              hit = true; // If there is a hit then the
                        					// variable will be change to
                        					// true
                        
                           if (hit) {// If the bullet hit the target:
                              tempBullet.isAlive = false;// The bullet is
                           								// deleted from
                           								// the screen
                           
                              if (targets[a][i].lives > 0) {// If the
                              								// target
                              								// had more
                              								// than 0,
                              								// subtract
                              								// 1
                                 targets[a][i].lives -= 1;
                              }
                              if (targets[a][i].lives == 0) {// if target
                              								// has 0
                              								// lives,
                              								// delete
                              								// the icon
                              								// from the
                              								// screen
                                 targets[a][i].isAlive = false;
                                 enemyClip.play();
                              }
                           }
                        }
                     
                        if (tempBullet.isAlive && tempBullet.y <= 0) // if
                        												// bullet
                        												// flew
                        												// off
                        												// the
                        												// screen
                        												// without
                        												// hitting
                        												// any
                        												// targets
                           tempBullet.isAlive = false;
                     }
                  }
               
               	// Check the position of the bullet corresponding to the
               	// obstacle:
                  for (int i = 0; i < obstacles.length; i++) {
                  
                     boolean hit = false;
                  
                     if (obstacles[i].isAlive) {
                     
                        if (tempBullet.x >= obstacles[i].x && tempBullet.x <= obstacles[i].x + 55
                        		&& tempBullet.y >= obstacles[i].y && tempBullet.y <= obstacles[i].y + 30)
                        
                           hit = true;
                     
                        if (hit) {
                           tempBullet.isAlive = false;
                           obstacles[i].lives -= 1; // reduces the brick
                        								// life by 1;
                        }
                        if (obstacles[i].lives == 0) {
                           obstacles[i].isAlive = false; // brick dies
                        									// after 5 hits
                        }
                     }
                  }
               }
            }
         
         	// -----------------------------THE ENEMY BULLET-------------------------------------------
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
               
                  for (Iterator<Bullet> it = targets[a][i].bulletsE.iterator(); it.hasNext();/* NO arg */) {
                  
                  	// Checking the position of the BULLET of EACH ENEMY:
                  
                     Bullet temp = it.next();
                  
                     if (temp.isAlive) {
                     
                        boolean hit = false;
                     
                     	// Check if one of the bullets of the enemy match
                     	// the location of the player:
                        if (temp.x >= player.x && temp.x <= player.x + 50 && temp.y >= player.y
                        		&& temp.y <= player.y + 50) {
                           hit = true;
                        }
                        if (hit) {// If the bullet hit the Player:
                           temp.isAlive = false;// The enemy's bullet is deleted from the screen
                        
                           if (player.lives > 0) {// If the Player had more than 0, subtract 1
                              player.lives -= 1;
                           }
                        }
                     }
                  
                  	// If there was no hit:
                     if (temp.isAlive && temp.y >= 800){ //if bullet flew off the screen without hitting any targets
                        isAnyAliveEnemyBullets = false;// ?????????????????????? NOT SURE!!!!!!!!!!!!!!!!
                        temp.isAlive = false;
                     }
                  }
               }
            }
         }
      
         public boolean isGameOver() { // Checks if alive targets are left
         
            boolean gameOver = true;
         
            Dead: for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
               
                  if (targets[a][i].isAlive) {
                     gameOver = false;
                  
                  	// If the player didn't kill all the targets he/she
                  	// automatically lose
                     if (targets[a][i].y == 500) {
                     
                        gameOver = true;
                        enemyAlive = true;
                     
                        playerClip.play();
                     
                        break Dead;
                     }
                  }
               }
            }
         
         	// ADD HERE THE CASE WHEN THE USER GOT KILLED BY THE ENEMY
            if (player.lives == 0) {
               playerClip.play();
               JOptionPane.showMessageDialog(null, "YOU'RE A DEAD MEAT!!!");
            
               gameOver = true;
            }
         
            return gameOver;
         }
      
         public void enemyShoot() {
         
            //synchronized(this){
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
               
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
                  
                  // if there is an enemy at the corrent location AND there
                  // is no bullets on the screen from the enemy then:
                  if (targets[a][i].isAlive && !isAnyAliveEnemyBullets) {
                     enemyShoot.play();
                     // Releases a bullet from where the player currently is:
                     Bullet enemyBullet = new Bullet(targets[a][i].x + 10, targets[a][i].y + 35, 1);
                      // Add the bullet to the list of Bullets:
                     targets[a][i].bulletsE.add(enemyBullet); 
                     // Add the bullet to the screen:
                     add(enemyBullet); 
                  }
               }
            }
            //}
         }
      
         public void startMenue() {
         
         	// JOptionPane to inform about selcting the level"
            JLabel difficulty = new JLabel("Please choose a level of dificulty from the menue");
            difficulty.setFont(new Font("Arial", Font.BOLD, 18));
            JOptionPane.showMessageDialog(null, difficulty, "DIFFICULTY", JOptionPane.WARNING_MESSAGE);
         
         	// Create the options for the player:
            String[] options = { "Grandma (Easy)", "Player (Mid)", "KILL ZONE (Hard)" };
            JComboBox optionsMenue = new JComboBox(options);
            optionsMenue.setEditable(false);
            JOptionPane.showMessageDialog(null, optionsMenue, "SELECT YOUR LEVEL!", JOptionPane.QUESTION_MESSAGE);
         
         	// Adjust the difficulty accordingly:
            switch (optionsMenue.getSelectedIndex()) {
            
               case 0:// Easy
                  {
                     TARGET_LIVES = 1;
                     TARGET_SPEED = 1;
                     break;
                  }
               case 1:// Mid
                  {
                     TARGET_LIVES = 2;
                     TARGET_SPEED = 2;
                     break;
                  }
               case 2:// Hard
                  {
                     TARGET_LIVES = 3;
                     TARGET_SPEED = 3;
                     break;
                  }
            }
         	// return optionsMenue;
         }
      
         @Override public void keyTyped(KeyEvent e) {/* not in use */}
         @Override public void keyReleased(KeyEvent e) {/* not in use */}
         @Override public void keyPressed(KeyEvent e) {
         
            int code = e.getKeyCode();
         
            if (code == KeyEvent.VK_RIGHT) {
            
               if (!(player.x >= 700)) {
                  player.x = player.x + 10;
               }
            }
            
            else if (code == KeyEvent.VK_LEFT) {
            
               if (!(player.x <= 0)) {
                  player.x = player.x - 10;
               }
            }
            
            else if (code == KeyEvent.VK_SPACE) { // releases a bullet each time
            										// SPACE pressed
                                          
            // Checks that there is no bullets in the screen before shooting new one:
               if (!isAnyAlive) { 
                  playerShoot.play();
                  // Releases a bullet from where the player currently is:
                  Bullet bullet = new Bullet(player.x + 29, player.y + 0, 0); 
                  player.bulletsP.add(bullet); // add the bullet to the list of Bullets
                  add(bullet); // add the bullet to the screen
               }
            }
         }
      
         public void gameRun(ImageIcon player, ImageIcon enemy, ImageIcon obstacles) {
         
            //Removing the menu panel:
            //mainWindow.getContentPane().remove(menuePanel);
            mainWindow.getContentPane().removeAll();
            //Adding the new panel for the game:
            mainWindow.getContentPane().add(gameObj);
            //mainWindow.pack();
            mainWindow.requestFocusInWindow();
            mainWindow.setVisible(true);
                        
            while(true){
            
               gameObj.moveObjects();
               gameObj.enemyShoot();
               gameObj.anyHit();
               try {Thread.sleep(30);} 
               catch (Exception e) {e.printStackTrace();}
               gameObj.repaint();
            }
         }
      }
   
      public static void main(String[] args) {
      
      	// Improving the basic java look and feel:
      	// DO NOT MOVE IT TO SOMEWHERE ELSE
         try {UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());} 
         catch (Exception e){e.printStackTrace();}
      
         //Playing the main clip for the game:
         //mainClip.loop();
      
         //An object to this class to call the constractor:
         new Space_invadors();
      }
   } 
   
   version 4:
   
      /**
    * © All rights reserved for Alon Butbul, a copy and/or implementing of that class or any other class in this 
    * project without a written consent from Alon Butbul, will results in a serious issue 
    * and will lead to further actions in court. 
    * 
    * @author Alon Butbul 
    * @version 1.0
    * 
    * 
    * The Space_invadors class is used to create a game in which the user will be able to 
    * interact with the program using the java GUI interface.
    * 
    * That particular class extending and implementing other classes such as JFrame or KeyListener, <--------- OR?????
    * to construct a full functioning interactive game.
    * */
   
   import java.awt.event.ActionEvent;
   import java.awt.event.ActionListener;
   import java.awt.Graphics;
   import java.awt.Image;
   import java.awt.event.KeyEvent;
   import java.awt.event.KeyListener;
   import java.awt.Dimension;
   import java.awt.Toolkit;
   import java.awt.*;
   
   import java.util.Iterator;
   import javax.swing.ImageIcon;
   import javax.swing.JFrame;
   import javax.swing.JOptionPane;
   import javax.swing.JPanel;
   import javax.swing.JButton;
   import javax.swing.*;
   
   import java.applet.Applet;
   import java.applet.AudioClip;
   import java.net.URL;
   
   public class Space_invadors{
   
      private static JFrame mainWindow = new JFrame(); 
      
   	// The background sound for the game:
      private static URL mainURL = Space_invadors.class.getResource("backSound.wav");
      private static AudioClip mainClip = Applet.newAudioClip(mainURL);
   
      //An object to the Game class:
      private Game gameObj = new Game(null, null, null); 
      
      //A panel for the player menue:
      //private JPanel menuePanel; 
      
      //Centering the JFrame:
      //private final static Dimension auotDim = Toolkit.getDefaultToolkit().getScreenSize();
      
      public Space_invadors(){
      
         //System.out.println(javax.swing.SwingUtilities.isEventDispatchThread());
         
         //Creating the window:
         frameCreate();
         
         //Calling the player menue:
         new StartMenus();
         
         //gameObj.gameRun(null,null,null);
      }
      
      private void frameCreate(){
      
         mainWindow.setTitle("Space Invaders");
         mainWindow.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
         mainWindow.setSize(800, 800);
         mainWindow.setResizable(false);
         //mainWindow.setLocation(auotDim.width / 2 - mainWindow.getSize().width / 2, auotDim.height / 2 - mainWindow.getSize().height / 2);
         mainWindow.setLocationRelativeTo(null);
         mainWindow.setLayout(new GridLayout(0, 1));
         //setVisible(false); <-- By default it's false
      }
   
      private class StartMenus extends JPanel implements ActionListener{
            
         URL[] players = { Space_invadors.class.getResource("menuePlayer1.png"),
                     		Space_invadors.class.getResource("menuePlayer2.png"),
                     		Space_invadors.class.getResource("menuePlayer3.png"),
                     		Space_invadors.class.getResource("menuePlayer4.png") };
                           
         JButton[] playerButtons = {new JButton("Blue Knight", new ImageIcon(players[0])),
                              		new JButton("Terminator",  new ImageIcon(players[1])),
                              		new JButton("Red Eagle",   new ImageIcon(players[2])),
                              		new JButton("Phantom",     new ImageIcon(players[3])), 
                                    new JButton("DEFAULT")};
      
         public StartMenus() {
         
         	// Menu one - Introduction:
            JLabel welcome = new JLabel("Hello player and wellcome! \n" + 
                                        "Please choose your desired spaceship from the following menue!");
            welcome.setFont(new Font("Arial", Font.BOLD, 18));
            JOptionPane.showMessageDialog(null, welcome, "WELCOME", JOptionPane.WARNING_MESSAGE);
            
            //Panel one for the player menu:
            //menuePanel = new JPanel(new GridLayout(0, 1)); 
            
            setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
            add(Box.createVerticalStrut(0));
            
         	// Setting the color of each button:
            for (JButton x : playerButtons) {
            
               x.setFont(new Font(Font.SANS_SERIF, Font.BOLD, 50));
            
               if (x == playerButtons[0])
                  playerButtons[0].setForeground(Color.BLUE);
               else if (x == playerButtons[1])
                  playerButtons[1].setForeground(Color.YELLOW);
               else if (x == playerButtons[2])
                  playerButtons[2].setForeground(Color.RED);
               else if (x == playerButtons[3])
                  playerButtons[3].setForeground(Color.GRAY);
               else
                  playerButtons[4].setForeground(Color.BLACK);
            
               // Assigning actionListener to each buttom:
               x.addActionListener(this);
               
               //Align the buttons in the center:
               x.setAlignmentX(CENTER_ALIGNMENT); 
               //Add the buttons to the panel:
               add(x);
            }
         
            //Keeping the buttons together:
            add(Box.createVerticalGlue());
            
         	/*// Assigning actionListener to each buttom
            for(int i = 0; i < 5; i++){
               playerButtons[i].addActionListener(this);
            }*/
            
            //Adding the panel to the JFrame and make the JFrame visible:     
            mainWindow.getContentPane().add(this);
            mainWindow.setVisible(true);
         }
         
         public void actionPerformed(ActionEvent e){
         
            //mainWindow.dispose();
            mainWindow.setVisible(false);
                     
            if (e.getActionCommand() == "Blue Knight")
               gameObj.gameRun(new ImageIcon(players[0]), null, null);
            else if (e.getActionCommand() == "Terminator")
               gameObj.gameRun(new ImageIcon(players[1]), null, null);
            else if (e.getActionCommand() == "Red Eagle")
               gameObj.gameRun(new ImageIcon(players[2]), null, null);
            else if (e.getActionCommand() == "Phantom")
               gameObj.gameRun(new ImageIcon(players[3]), null, null);
            else//Default
               gameObj.gameRun(null, null, null);
         }
      }
   
      private class Game extends JPanel implements KeyListener {
      
      	// JProgressBar prg; 
         
         private Image background;
      	// private ImageIcon deadMeat = new ImageIcon(this.getClass().getResource("Explosion.png")); // Add the explosion!!!!
         
         private static final int NUM_OF_TARGETS_COL = 10;// Can't be less than 10
         private static final int NUM_OF_TARGETS_ROW = 3;
         private static final int NUM_OF_OBSTACLES = 7;
      
         private int targetsVelocity = 0; // initial velocity of targets
         private int TARGET_LIVES = 1; // minimum life for the target
         private int TARGET_SPEED = 1; // minimum speed for the target
         // 2D array to hold more than 1 row of enemy:
         private Target[][] targets = new Target[NUM_OF_TARGETS_ROW][NUM_OF_TARGETS_COL]; 
      
         private Player player;
         private int PLAYER_LIVES = 3; // minimum life for the player
      
         private Obstacle[] obstacles = new Obstacle[NUM_OF_OBSTACLES];
      
         private boolean isAnyAlive = false; // Used with the player's bullets to determine if they are excited on the screen
         private boolean isAnyAliveEnemyBullets = false; // Used for the enemy's bullets
         private boolean enemyAlive = false; // If the player didn't kill all the targets then a different menue will be shown
      
         private URL enemyDie = Space_invadors.class.getResource("enemyDying.wav");
         private URL playerDie = Space_invadors.class.getResource("playerDying.wav");
         private URL enemyS = Space_invadors.class.getResource("enemyShoot.wav");
         private URL playerS = Space_invadors.class.getResource("playerShoot.wav");
         private AudioClip enemyClip = Applet.newAudioClip(enemyDie);
         private AudioClip playerClip = Applet.newAudioClip(playerDie);
         private AudioClip enemyShoot = Applet.newAudioClip(enemyS);
         private AudioClip playerShoot = Applet.newAudioClip(playerS);
      
         private JComboBox optionsMenue;
         private URL mainURL = Space_invadors.class.getResource("backSound.wav");
         private AudioClip mainClip = Applet.newAudioClip(mainURL);
      
         //private final Dimension autoDim = Toolkit.getDefaultToolkit().getScreenSize();
      
         public int change = 0;
      
      	/**
      	 * The constractor of the class will instantiate the obstacle, target,
      	 * Bullet and the player classes in order to create full functioning
      	 * game. Also, will create a new object for the background image.
      	 * 
      	 * @param obstaclesIcon - Passing an image parameter to replace the default one
      	 *  for the obstacle view.
      	 * @param enemyIcon - Passing an image parameter to replace the default one
      	 *  for the enemy view.
      	 * @param playerIcon - Passing an image parameter to replace the default one
      	 *  for the player view.
      	 */
         public Game(ImageIcon playerIcon, ImageIcon enemyIcon, ImageIcon obstaclesIcon) {
            
         	// enemyDie = Space_invadors.class.getResource("Dying1.wav");
         	// enemyClip = Applet.newAudioClip(enemyDie);
         	/*
         	 * prg = new JProgressBar(0,100); prg.setValue(100);
         	 * prg.setStringPainted(true); prg.setEnabled(true); add(prg);
         	 * //prg.setString("100");
         	 */
         
         	// Add the background:
            background = new ImageIcon(getClass().getResource("BackGray.jpg")).getImage();
            
         	// Creates obstacles
            int obstacleX = 25, lives = 5; // each brick has 5 lives
            for (int i = 0; i < obstacles.length; i++, obstacleX += 100) {
            
               if (obstaclesIcon == null)
                  obstacles[i] = new Obstacle(null, obstacleX + 50, 500, lives);
               else
                  obstacles[i] = new Obstacle(obstaclesIcon.getImage(), obstacleX + 50, 500, lives);
            
               add(obstacles[i]);
            }
         
         	// Create targets
            int targetX = 0, targetY = 50;
         
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++, targetX += 50) {
               
                  if (enemyIcon == null)
                     targets[a][i] = new Target(null, targetX, targetY, TARGET_LIVES);
                  else
                     targets[a][i] = new Target(enemyIcon.getImage(), targetX, targetY, TARGET_LIVES);
               
                  add(targets[a][i]);
               }
            
               targetY += 50;
               targetX = 0;
            }
         
         	// Create the player:
            if (playerIcon == null)
               player = new Player(null, 350, 650, PLAYER_LIVES, 0);
            else
               player = new Player(playerIcon.getImage(), 350, 650, PLAYER_LIVES, 0);
         
            add(player); // Adds player to the panel
            
            this.addKeyListener(this); // Adds keyListener to the panel
            
            this.setFocusable(true);
         }
      
      	/**
      	 * The paint method is used to paint an object as a graphical user
      	 * interface. The paintComponent method will be called from the repaint
      	 * method.
      	 * 
      	 * @param g
      	 *            - The specified graphic object to paint in the window
      	 *            (self-customize one)
      	 */
         @Override
         protected void paintComponent(Graphics g) {
         
         	// The background of the window will be drawn manually, therefore no
         	// need for:
         	// super.paintComponent(g); //Passes the graphics context off to the
         	// component's UI delegate, which paints the panel's background
         
            g.drawImage(background, 0, 0, getWidth(), getHeight(), null);
         
            player.drawPlayer(g); // draws player on the screen
         
            for (int i = 0; i < obstacles.length; i++)
               obstacles[i].drawObstacles(g); // draws obstacles on the screen
         
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) { // draws targets on
            												// the screen
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
               
                  targets[a][i].drawTarget(g);
               
               	// Drawing the bullets for the enemy:
                  for (Iterator<Bullet> it = targets[a][i].bulletsE.iterator(); it
                  		.hasNext();/* NO arg */) {
                  
                     Bullet temp = it.next();
                     temp.drawBullet(g);
                  }
               }
            }
         
         	// Drawing the bullets for the player:
            for (Iterator<Bullet> it = player.bulletsP.iterator(); it.hasNext();) {// bullets.iterator()
               Bullet b = it.next();
               b.drawBullet(g); // draws player bullets on the screen from the
            						// Player class
            }
         
            g.dispose();// if i cancel that line there are gray squers on top
         				// for some reason
         }
      
      	/**
      	 * moveObjects method is used to move the objects on the screen, in this
      	 * case the objects are the bullets/targets. The method will not paint
      	 * the objects, it will only move them to a different location on the
      	 * panel.
      	 */
         public void moveObjects() {
         
         /*Creating a local variable to direct the enemy on the y-value, 
           after the enemy reached every edge, it will go down ten levels:*/
            int moveY = 0;
         
         	/*
         	 * The interface Iterator<E> is a linked list that takes a type
         	 * Bullet (from the Bullet class) and iterate among the elements
         	 * inside the linked list that the Bullet class has. E - The type of
         	 * elements returned by this iterator (Bullet object)
         	 * 
         	 * The "it" is a pointer pointing to the head of the list and as
         	 * long that .iterator returns another element the for loop will
         	 * continue
         	 */
         	// Moving the player bullets:
            for (Iterator<Bullet> it = player.bulletsP.iterator(); it.hasNext();/* NO arg */) {
            
               Bullet tempBullet = it.next(); // pull out a Bullet objects from the list; 1 each time
               isAnyAlive = tempBullet.isAlive ? true : false;
               tempBullet.y = tempBullet.y - 13; // move the bullet 13 pixels up each repaint()
            }
         
         	// ----------------------------------------------------------------------------------------------------------------------------------
         	// Check if the targets got to either one of the sides:
            if (targets[0][NUM_OF_TARGETS_COL - 1].x == 750) { // targets move
            													// in relation
            													// to the far
            													// right target
               targetsVelocity = -1 * TARGET_SPEED; // targets move left
               moveY = 10; // targets go down one row
            } 
            else if (targets[0][NUM_OF_TARGETS_COL - 1].x == 450) { // targets
            															// move
            															// in
            															// relation
            															// to
            															// the
            															// far
            															// left
            															// target
               targetsVelocity = TARGET_SPEED; // targets move right
               moveY = 10; // targets go down one row
            }
         	// ----------------------------------------------------------------------------------------------------------------------------------
         
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
               
               	// ---------------------------------------------------------------------------------------
                  for (Iterator<Bullet> it = targets[a][i].bulletsE.iterator(); it
                  		.hasNext();/* NO arg */) {
                  
                     Bullet temp = it.next();
                     isAnyAliveEnemyBullets = temp.isAlive ? true : false;
                     temp.y += 6;
                  }
               	// ---------------------------------------------------------------------------------------
               
                  targets[a][i].x = targets[a][i].x + targetsVelocity; // move
               															// the
               															// targets
               															// to
               															// either
               															// left
               															// or
               															// right
                  targets[a][i].y = targets[a][i].y + moveY; // move the
               												// targets down
               }
            }
         }
      
      	/**
      	 * The anyHit method measuring the bullet and the target x and y axis to
      	 * report if ther's a hit or not.
      	 */
         public void anyHit() { // compares each bullet x,y to each target x,y
         
         	// -----------------------------THE PLAYER BULLET-------------------------------------------
            for (Iterator<Bullet> it = player.bulletsP.iterator(); it.hasNext(); /* NO args */) {
            
               Bullet tempBullet = it.next(); // pulling out 1 bullet object
            									// from the list at a time
            
               if (tempBullet.isAlive) { // if bullet is still on the screen
               	// Check the position of the bullet corresponding to the
               	// target:
                  for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
                  
                     for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
                     
                        if (targets[a][i].isAlive) { // If the enemy is
                        								// still in the game
                        
                           boolean hit = false;
                        
                        	// Checking for matching locations:
                           if (tempBullet.x >= targets[a][i].x && tempBullet.x <= targets[a][i].x + 50
                           		&& tempBullet.y >= targets[a][i].y && tempBullet.y <= targets[a][i].y + 50)
                              hit = true; // If there is a hit then the
                        					// variable will be change to
                        					// true
                        
                           if (hit) {// If the bullet hit the target:
                              tempBullet.isAlive = false;// The bullet is
                           								// deleted from
                           								// the screen
                           
                              if (targets[a][i].lives > 0) {// If the
                              								// target
                              								// had more
                              								// than 0,
                              								// subtract
                              								// 1
                                 targets[a][i].lives -= 1;
                              }
                              if (targets[a][i].lives == 0) {// if target
                              								// has 0
                              								// lives,
                              								// delete
                              								// the icon
                              								// from the
                              								// screen
                                 targets[a][i].isAlive = false;
                                 enemyClip.play();
                              }
                           }
                        }
                     
                        if (tempBullet.isAlive && tempBullet.y <= 0) // if
                        												// bullet
                        												// flew
                        												// off
                        												// the
                        												// screen
                        												// without
                        												// hitting
                        												// any
                        												// targets
                           tempBullet.isAlive = false;
                     }
                  }
               
               	// Check the position of the bullet corresponding to the
               	// obstacle:
                  for (int i = 0; i < obstacles.length; i++) {
                  
                     boolean hit = false;
                  
                     if (obstacles[i].isAlive) {
                     
                        if (tempBullet.x >= obstacles[i].x && tempBullet.x <= obstacles[i].x + 55
                        		&& tempBullet.y >= obstacles[i].y && tempBullet.y <= obstacles[i].y + 30)
                        
                           hit = true;
                     
                        if (hit) {
                           tempBullet.isAlive = false;
                           obstacles[i].lives -= 1; // reduces the brick
                        								// life by 1;
                        }
                        if (obstacles[i].lives == 0) {
                           obstacles[i].isAlive = false; // brick dies
                        									// after 5 hits
                        }
                     }
                  }
               }
            }
         
         	// -----------------------------THE ENEMY BULLET-------------------------------------------
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
               
                  for (Iterator<Bullet> it = targets[a][i].bulletsE.iterator(); it.hasNext();/* NO arg */) {
                  
                  	// Checking the position of the BULLET of EACH ENEMY:
                  
                     Bullet temp = it.next();
                  
                     if (temp.isAlive) {
                     
                        boolean hit = false;
                     
                     	// Check if one of the bullets of the enemy match
                     	// the location of the player:
                        if (temp.x >= player.x && temp.x <= player.x + 50 && temp.y >= player.y
                        		&& temp.y <= player.y + 50) {
                           hit = true;
                        }
                        if (hit) {// If the bullet hit the Player:
                           temp.isAlive = false;// The enemy's bullet is deleted from the screen
                        
                           if (player.lives > 0) {// If the Player had more than 0, subtract 1
                              player.lives -= 1;
                           }
                        }
                     }
                  
                  	// If there was no hit:
                     if (temp.isAlive && temp.y >= 800){ //if bullet flew off the screen without hitting any targets
                        isAnyAliveEnemyBullets = false;// ?????????????????????? NOT SURE!!!!!!!!!!!!!!!!
                        temp.isAlive = false;
                     }
                  }
               }
            }
         }
      
         public boolean isGameOver() { // Checks if alive targets are left
         
            boolean gameOver = true;
         
            Dead: for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
            
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
               
                  if (targets[a][i].isAlive) {
                     gameOver = false;
                  
                  	// If the player didn't kill all the targets he/she
                  	// automatically lose
                     if (targets[a][i].y == 500) {
                     
                        gameOver = true;
                        enemyAlive = true;
                     
                        playerClip.play();
                     
                        break Dead;
                     }
                  }
               }
            }
         
         	// ADD HERE THE CASE WHEN THE USER GOT KILLED BY THE ENEMY
            if (player.lives == 0) {
               playerClip.play();
               JOptionPane.showMessageDialog(null, "YOU'RE A DEAD MEAT!!!");
            
               gameOver = true;
            }
         
            return gameOver;
         }
      
         public void enemyShoot() {
         
            //synchronized(this){
            for (int a = 0; a < NUM_OF_TARGETS_ROW; a++) {
               
               for (int i = 0; i < NUM_OF_TARGETS_COL; i++) {
                  
                  // if there is an enemy at the corrent location AND there
                  // is no bullets on the screen from the enemy then:
                  if (targets[a][i].isAlive && !isAnyAliveEnemyBullets) {
                     enemyShoot.play();
                     // Releases a bullet from where the player currently is:
                     Bullet enemyBullet = new Bullet(targets[a][i].x + 10, targets[a][i].y + 35, 1);
                      // Add the bullet to the list of Bullets:
                     targets[a][i].bulletsE.add(enemyBullet); 
                     // Add the bullet to the screen:
                     add(enemyBullet); 
                  }
               }
            }
            //}
         }
      
         public void startMenue() {
         
         	// JOptionPane to inform about selcting the level"
            JLabel difficulty = new JLabel("Please choose a level of dificulty from the menue");
            difficulty.setFont(new Font("Arial", Font.BOLD, 18));
            JOptionPane.showMessageDialog(null, difficulty, "DIFFICULTY", JOptionPane.WARNING_MESSAGE);
         
         	// Create the options for the player:
            String[] options = { "Grandma (Easy)", "Player (Mid)", "KILL ZONE (Hard)" };
            JComboBox optionsMenue = new JComboBox(options);
            optionsMenue.setEditable(false);
            JOptionPane.showMessageDialog(null, optionsMenue, "SELECT YOUR LEVEL!", JOptionPane.QUESTION_MESSAGE);
         
         	// Adjust the difficulty accordingly:
            switch (optionsMenue.getSelectedIndex()) {
            
               case 0:// Easy
                  {
                     TARGET_LIVES = 1;
                     TARGET_SPEED = 1;
                     break;
                  }
               case 1:// Mid
                  {
                     TARGET_LIVES = 2;
                     TARGET_SPEED = 2;
                     break;
                  }
               case 2:// Hard
                  {
                     TARGET_LIVES = 3;
                     TARGET_SPEED = 3;
                     break;
                  }
            }
         	// return optionsMenue;
         }
      
         @Override public void keyTyped(KeyEvent e) {/* not in use */}
         @Override public void keyReleased(KeyEvent e) {/* not in use */}
         @Override public void keyPressed(KeyEvent e) {
         
            int code = e.getKeyCode();
         
            if (code == KeyEvent.VK_RIGHT) {
            
               if (!(player.x >= 700)) {
                  player.x = player.x + 10;
               }
            }
            
            else if (code == KeyEvent.VK_LEFT) {
            
               if (!(player.x <= 0)) {
                  player.x = player.x - 10;
               }
            }
            
            else if (code == KeyEvent.VK_SPACE) { // releases a bullet each time
            										// SPACE pressed
                                          
            // Checks that there is no bullets in the screen before shooting new one:
               if (!isAnyAlive) { 
                  playerShoot.play();
                  // Releases a bullet from where the player currently is:
                  Bullet bullet = new Bullet(player.x + 29, player.y + 0, 0); 
                  player.bulletsP.add(bullet); // add the bullet to the list of Bullets
                  add(bullet); // add the bullet to the screen
               }
            }
         }
      
         public void gameRun(ImageIcon player, ImageIcon enemy, ImageIcon obstacles) {
         
            //Removing the menu panel:
            //mainWindow.getContentPane().remove(menuePanel);
            mainWindow.getContentPane().removeAll();
            //Adding the new panel for the game:
            mainWindow.getContentPane().add(gameObj);
            //mainWindow.pack();
            mainWindow.requestFocusInWindow();
            mainWindow.setVisible(true);
                        
            while(true){
            
               gameObj.moveObjects();
               gameObj.enemyShoot();
               gameObj.anyHit();
               try {Thread.sleep(30);} 
               catch (Exception e) {e.printStackTrace();}
               gameObj.repaint();
            }
         }
      }
   
      public static void main(String[] args) {
      
      	// Improving the basic java look and feel:
      	// DO NOT MOVE IT TO SOMEWHERE ELSE
         try {UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());} 
         catch (Exception e){e.printStackTrace();}
      
         //Playing the main clip for the game:
         //mainClip.loop();
      
         //An object to this class to call the constractor:
         new Space_invadors();
      }
   }